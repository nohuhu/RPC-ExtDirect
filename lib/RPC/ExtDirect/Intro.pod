=pod

=head1 NAME

RPC::ExtDirect::Intro - A gentle(ish) introduction to RPC::ExtDirect

=head1 DESCRIPTION

=head2 What is Ext.Direct?

Ext.Direct is a high level RPC-over-HTTP protocol provided out of the box
with L<Ext JS|http://www.sencha.com/products/extjs/> JavaScript framework.
It is server agnostic, provided that the server side stack is conformant
to L<Ext.Direct specification|http://www.sencha.com/products/extjs/extdirect/>.

L<RPC::ExtDirect> is a fully featured implementation of Ext.Direct protocol
in Perl, compatible with Ext JS 4.x and 5.x.

=head2 What Ext.Direct is for?

The primary goal for Ext.Direct is easy and fast integration of server
components with JavaScript interface. Client side stack is built in Ext JS
core and is used by many components like data Stores, Forms, Grids, Charts,
etc. Ext.Direct supports request batching, file uploads, event polling and
many other features.

Besides simplicity and ease of use, Ext.Direct allows to achieve very clean
code and issue separation both on server and client sides, which in turn
results in simplified code, greater overall software quality and shorter
development times.

From Perl module developer perspective, Ext.Direct is just a transport layer;
it doesn't matter if a method is called from Perl code or through
Ext.Direct. This approach, in particular, allows for multi-tiered testing:

=over 4 

=item *

Server side methods can be tested without setting up HTTP environment
with the usual tools like L<Test::More>

=item *

Server side classes can be tested as a whole via Ext.Direct calls
using L<Perl client|RPC::ExtDirect::Client>

=item *

Major application components are tested with browser automation tools
like Selenium.

=back

=head2 Terminology

Ext.Direct uses the following terms, followed by their descriptions:

=over 4

=item API

Description of server side calls exposed to client side. API consists
of L<remoting|/"Remoting API"> and L<polling|/"Polling API"> parts.

=item API declaration

JavaScript chunk that encodes L</API>. Usually generated
by application server and retrieved by client once upon startup.
Another option is to embed API declaration in client side application
code.

API declaration is generated by L<RPC::ExtDirect::API> module.

=item Remoting API

The main part of the L</"API declaration">, it declares the L<Actions|/Action>
and L<Methods|/Method> available to the client, as well as their calling
patterns, and other parameters.

=item Polling API

Used to declare the existence of L<Event Providers|/"Event Provider"> and
their credentials, basically the URI to use.

=item Router

Server side component that receives remoting calls, dispatches requests,
collects and returns call L<Results|/Result> or L<Exceptions|/Exception>.

=item Action

Namespace unit; collection of L<Methods|/Method>. The nearest Perl analog
is a package, other languages may call it a Class.

Since Ext.Direct originated in JavaScript, '::' will be replaced with dots
for all Actions in the L</"API declaration">, and should be called as
C<Action.Method()> instead of Perl style C<Action::Method>.

=item Method

Subroutine exposed through Ext.Direct API to be called by client side.
Method is fully qualified by L</Action> and Method names using a dot as
the delimiter: C<Action.Method>.

=item Method stub

JavaScript function created by the Ext.Direct transport layer on the client
side I<in lieu> of the actual L</Method> that only exists on the server
side. A separate stub will be created for each Method, with the parameter
signature conforming to Method's declaration in the L</API>.

=item Ordered Method

A L</Method> that accepts zero or more parameters in ordered fashion, or by
position (in a list). See more in
L<Method calling conventions|RPC::ExtDirect::API/"Method calling conventions">.

=item Named Method

A L</Method> that accepts parameters by name, in a hash. See more in
L<Method calling conventions|RPC::ExtDirect::API/"Method calling conventions">.

=item Form Handler Method

A L</Method> that accepts form submits. All form field values are passed to
the Form handler in a hash, C<field => value>. The only practical reason to
use Form handlers is to process file uploads; see
L<FILE UPLOADS|RPC::ExtDirect/"FILE UPLOADS"> for more information.

=item Poll Handler Method

A L</Method> that is called by an L</"Event Provider"> to return the list of
L<Events|/Event> to be passed on to the client side.

=item Result

Any data returned by a L</Method> upon successful or unsuccessful call
completion. This includes application logic errors. 'Not authenticated'
and alike events should be returned as Results, not L<Exceptions|/Exception>.

=item Exception

Fatal error, or any other unrecoverable event in the application code.
Calls that produce Exception instead of L</Result> are considered
unsuccessful; Ext.Direct provides built in mechanism for managing
Exceptions.

Exceptions are not used to indicate errors in application logic flow,
only for catastrophic conditions. Nearest analog is status code 500
for HTTP responses.

Examples of Exceptions are: request JSON is broken and can't be decoded;
called Method dies because of internall error; Result cannot be encoded
in JSON, etc.

=item Event

An asynchronous notification that can be generated by server side and
passed to client side, resulting in some reaction. Events are useful
for status updates, progress indicators and other predictably occuring
conditions and events.

=item Event Provider

Server side script that gets polled by client side every C<n> seconds;
default C<n> is 3 but it can be changed in client side configuration.

=back

=head1 ARCHITECTURE OVERVIEW

Ext.Direct is not only a transport protocol; in fact it implies a set
of requirements for the server side to meet. There are many web server
environments available in the Perl world, with several major interface
conventions established over the years. These environments are common
in the way that all of them implement HTTP request/response model;
however the particular details can differ significantly.

To deal with the web server differences, RPC::ExtDirect adopted the
core-periphery architecture. Transport layer core, provided by the
L<RPC::ExtDirect> CPAN distribution, is complemented by a peripheral
distribution called a I<gateway> that works with a particular web
server environment. The gateway is responsible for implementing the
features missing in a web server interface, if any.

Since the gateway modules implement the "lowest denominator" abstraction
layer, it is fairly easy to use an Ext.Direct application with several
different gateways at the same time. The most common use for this is
testing; the added benefit is that the application becomes independent
of the web server environment and can be ported easily if such a need
arises.

=head1 GATEWAYS

At the time of writing this documentation, the following gateways
are available:

=over 4

=item CGI gateway

L<CGI::ExtDirect> is used with plain old L<CGI> environment; it is also
compatible with the newer L<CGI::Simple> module that is a drop-in
replacement for C<CGI.pm>.

This gateway is most often used for testing Ext.Direct interfaces, usually
with L<Test::ExtDirect> helper module. However, CGI environment is easy
to use and set up practically anywhere, and it can be used in the variety
of situations where a full blown Perl application server is not feasible.

One example of such usage would be retrofitting a legacy system with a
modern HTML5 Web application.

=item Plack gateway

L<Plack::Middleware::ExtDirect> implements an RPC::ExtDirect interface
for L<Plack> application server environment. This gateway should also be
used instead of the L<Apache gateway|/"Apache gateway"> in L<mod_perl2>
environment.

=item AnyEvent::HTTPD gateway

L<AnyEvent::HTTPD::ExtDirect> implements a completely asynchronous
interface for RPC::ExtDirect, based on L<AnyEvent::HTTPD> module.

=item Apache gateway

L<Apache::ExtDirect> is a legacy gateway for Apache/L<mod_perl2>
environment. Since it was written, Apache has fallen out of usage
and so the gateway is mostly unsupported, too. You can use
L<Plack gateway|/"Plack gateway"> instead, with one of the built in
Apache/Plack handlers.

=back

=head1 GETTING STARTED


 package Foo::Bar;
 
 use RPC::ExtDirect Action => 'Fubar',
                    before => \&package_before_hook,
                    after  => \&package_after_hook,
                    ;
  
 sub foo_custom_hook {
    # Check something, return true
    return 1;
 }
 
 sub foo : ExtDirect(2, before => \&foo_custom_hook) {
    my ($class, $arg1, $arg2) = @_;
  
    # do something, store results in scalar
    my $result = ...;
  
    return $result;
 }
  
 # This method doesn't need hooks for some reason
 sub bar
    : ExtDirect(
        params => ['foo', 'bar'], before => 'NONE', after => 'NONE',
      )
 {
    my ($class, %arg) = @_;
  
    my $foo = $arg{foo};
    my $bar = $arg{bar};
  
    # do something, returning scalar
    my $result = eval { ... };
  
    # or throw an exception if something's wrong
    die "Houston, we've got a problem: $@\n" if $@;
  
    return $result;
 }
  
 sub baz : ExtDirect(formHandler) {
    my ($class, %arg) = @_;
  
    my @form_fields    = grep { !/^file_uploads$/  } keys %arg;
    my @uploaded_files = @{ $arg{file_uploads}     };
  
    # do something with form fields and files
    my $result = { ... };
  
    return $result;
 }
  
 sub package_before_hook {
    my ($class, %params) = @_;
  
    # Unpack parameters
    my ($method, $env) = @params{ qw/method _env/ };
  
    # Decide if user is authorized to call this method
    my $authorized = check_authorization($method, $env);
  
    # Positive
    return 1 if $authorized;
  
    # Negative, return error string
    return 'Not authorized';
 }
  
 sub package_after_hook {
    my ($class, %params) = @_;
  
    # Unpack parameters
    my ($method, $result, $ex) = @params{ qw/method result exception/ };
    
    # Log the action
    security_audit_log($method, $result, $ex);
 }


=cut
