=pod

=head1 NAME

RPC::ExtDirect - Easily integrate Perl server code with JavaScript apps

=head1 SYNOPSIS

    package Foo::Bar;
    
    use RPC::ExtDirect;
    
    sub sum : ExtDirect(2) {
        my ($class, $a, $b) = @_;
        
        return $a + $b;
    }
    
    sub login : ExtDirect( params => [qw/ user pass /] ) {
        my ($class, %arg) = @_;
        
        if ( $arg{user} eq 'foo' && $arg{pass} eq 'bar' ) {
            return {
                success => \1,  # JSON::true
            };
        }
        else {
            return {
                success => \0,  # JSON::false
                error   => "You shall not pass!"
            };
        }
    }

=head1 DESCRIPTION

RPC::ExtDirect suite of modules provides an easy, simple and robust way to
write Perl server side code that could be used with Rich Internet Applications
based on JavaScript frameworks L<Ext JS|http://www.sencha.com/products/extjs/>
and L<Sencha Touch|http://www.sencha.com/products/touch/>.

The suite consists of the core RPC::ExtDirect module that implements Ext.Direct
protocol and transport layer, several server environment-specific gateways,
a standalone pure Perl server, two Perl clients, and even its own specialized
unit test helper! We've got it covered front to back. :)

=head1 WHEN TO USE IT, AND WHY

Ext.Direct is a Remote Procedure Call (RPC) protocol provided out of the box
with JavaScript frameworks by L<Sencha|http://www.sencha.com>. It is deeply
integrated in the data services, and is supported by a slew of components.
Besides that, Ext.Direct also has several major advantages over similar
protocols like XML-RPC and JSON-RPC:

=over 4

=item *

Built in service discovery mechanism: server side API is published to the
client via GET requests to a preconfigured URI

=item *

Dead simple client side invocation via functional stubs created from the
API declaration

=item *

Support for request batching with configurable timeout

=item *

Easy file uploads via form submits, with all the complexity handled behind
the curtains by the framework and server side stack

=item *

Asynchronous push notifications via event polling

=back

All this makes Ext.Direct a no-brainer when developing Web apps with Ext JS or
Sencha Touch. And with RPC::ExtDirect, choosing Perl to write server side code
for Web apps comes easy, too. :)

Besides HTML5 applications, it's also possible to use L<RPC::ExtDirect::Client>
to for pure Perl distributed RPC.

If that would not be enough, L<RPC::ExtDirect::Client> also makes pure Perl
distributed RPC less painful.

=head1 INTRODUCTION AND TUTORIAL

If you are not familiar with Ext.Direct, start with L<RPC::ExtDirect::Intro>
for more explanations and a few examples. There is also a 
L<tutorial|RPC::ExtDirect::Tutorial> that may be helpful at getting your feet
wet.

=head1 USING RPC::EXTDIRECT

=head2 Overview

Since Ext.Direct is just a transport layer, you don't need to change your app
architecture to work around it. If you have an existing server side API you
can publish it with minimal effort; if you're starting from scratch, add the
classes and methods as you go.

Note that with Ext.Direct, we're talking about classes and methods - that owes
to the fact that Ext.Direct originated in Ext JS framework, which itself is
written in JavaScript with object-oriented approach in mind. This does not mean
you can't go functional or even procedural with RPC::ExtDirect; it is perfectly
possible to cook your own flavor of spaghetti code under the light OOP sauce that
RPC::ExtDirect provides.

=head2 Service discovery

In order for a method to be published to the outside world, it needs to be
declared in the L<Ext.Direct API|RPC::ExtDirect::Intro/API>. As of version 3.0,
it can be done in two ways: either with C<ExtDirect> attribute as shown in the
L</SYNOPSIS>, or by including the method in a hashref fed to L<RPC::ExtDirect::API>
constructor. Note that these two methods are I<not> mutually exclusive, but it is
not recommended to mix them unless you really know how to deal with ensuing
timing issues. You've been warned.




In order to export subroutine to ExtDirect interface, use C<ExtDirect(n, ...)>
attribute in sub declaration. Note that there can be no space between
attribute name and opening parentheses. In Perls older than 5.12, attribute
declaration can't span multiple lines, i.e. the whole C<ExtDirect(n, ...)>
should fit in one line.

n is mandatory calling convention declaration; it may be one of the following
options:

=over 4

=item *

Number of arguments to be passed as ordered list

=item *

Names of arguments to be passed as hash

=item *

formHandler: method will receive hash of fields and file uploads

=item *

pollHandler: method that provides Events when polled by client

=back

Optional method attributes can be specified after calling convention
declaration, in hash-like C<key =E<gt> value> form. Optional attributes
are:

=over 4

=item *

before: code reference to use as "before" hook. See L</HOOKS>

=item *

instead: code reference to "instead" hook

=item *

after: code reference to "after" hook.

=back

=head1 METHODS

Unlike Ext.Direct specification (and reference PHP implementation, too)
RPC::ExtDirect does not impose strict architectural notation on server
side code. There is no mandatory object instantiation and no assumption
about the code called. That said, an RPC::ExtDirect Method should conform
to the following conventions:

=over 4

=item *

Be a class method, i.e. be aware that its first argument will be package name.
Just ignore it if you don't want it.

=item *

Ordered (numbered) arguments are passed as list in @_, so $_[1] is the first
argument. No more than number of arguments declared in ExtDirect attribute
will be passed to Method; any extra will be dropped silently. Less actual
arguments than declared will result in Exception returned to client side,
and Method never gets called.

The last argument is an environment object (see L<ENVIRONMENT OBJECTS>).
For methods that take 0 arguments, it will be the first argument after
class name.

=item *

Named arguments are passed as hash in @_. No arguments other than declared
will be passed to Method; extra arguments will be dropped silently. If not
all arguments are present in actual call, an Exception will be returned and
Method never gets called.

Environment object will be passed in '_env' key.

=item *

Form handlers are passed their arguments as hash in @_. Standard Ext.Direct
form fields are removed from argument hash; uploaded file(s) will be passed
in file_uploads hash element. It will only be present when there are uploaded
files. For more info, see L</UPLOADS>.

Environment object will be passed in '_env' key.

=item *

All remoting Methods are called in scalar context. Returning one scalar value
is OK; returning array- or hashref is OK too.

Do not return blessed objects; it is almost always not obvious how to
serialize them into JSON that is expected by
client side; JSON encoder will choke and an Exception will
be returned to the client.

=item *

If an error is encountered while processing request, throw
an exception: die "My error string\n". Note that "\n" at
the end of error string; if you don't add it, die() will
append file name and line number to the error message;
which is probably not the best idea for errors that are not
shown in console but rather passed on to JavaScript client.

RPC::ExtDirect will trim that last "\n" for you before
sending Exception back to client side.

=item *

Poll handler methods are called in list context and do not
receive any arguments except environment object. Return values
must be instantiated Event object(s), see L<RPC::ExtDirect::Event>
for more detail.

=back

=head1 HOOKS

Hooks provide an option to intercept method calls and modify arguments
passed to the methods, or cancel their execution. Hooks are intended
to be used as a shim between task-oriented Methods and Web specifics.

Methods should not, to the reasonable extent, be aware of their
environment or care about it; Hooks are expected to know how to deal with
Web intricacies but not be task oriented.

The best uses for Hooks are: application or package-wide pre-call setup,
user authorization, logging, cleanup, testing, etc.

A hook is a Perl subroutine (can be anonymous, too). Hooks can be of three
types:

=over 4

=item *

"Before" hook is called before the Method, and can be used
to change Method arguments or cancel Method execution. This
hook must return numeric value 1 to allow Method call. Any
other value will be interpreted as Ext.Direct Result; it
will be returned to client side and Method never gets called.

Note that RPC::ExtDirect will not make any assumptions about
this hook's return value; returning a false value like '' or 0
will probably look not too helpful from client side code.

If this hook throws an exception, it is returned as Ext.Direct
Exception to the client side, and the Method does not execute.

=item *

"Instead" hook replaces the Method it is assigned to. It is
the hook sub's responsibility to call (or not call) the Method
and return appropriate Result.

If this hook throws an exception, it is interpreted as if the
Method trew it.

=item *

"After" hook is called after the Method or "instead" hook. This
hook cannot affect Method execution, it is intended mostly for
logging and testing purposes; its input include Method's
Result or Exception.

This hook's return value and thrown exceptions are ignored.

=back

Hooks can be defined on three levels, in order of precedence: method,
package and global. For each Method, only one hook of each type can be
applied. Hooks specified in Method definition take precedence over all
other; if no method hook is found then package hook applies; and if
there is no package hook then global hook gets called, if any. To avoid
using hooks for a particular method, use 'NONE' instead of coderef;
this way you can specify global and/or package hooks and exclude some
specific Methods piecemeal.

Hooks are subject to the following calling conventions:

=over 4

=item *

Hook subroutine is called as a class method, i.e. first argument
is name of the package in which this sub was defined. Ignore it
if you don't need it.

=item *

Hooks receive a hash of the following arguments:

=over 8

=item action

Ext.Direct Action name for the Method

B<DEPRECATED>. Use L<method_ref|/method_ref> instead: C<<$method_ref->action>>

=item method

Ext.Direct Method name

B<DEPRECATED>. Use L<method_ref|/method_ref> instead: C<<$method_ref->name>>

=item package

Name of the package (not Action) where the Method is declared

B<DEPRECATED>. Use L<method_ref|/method_ref> instead: C<<$method_ref->package>>

=item code

Coderef to the Method subroutine

B<DEPRECATED>. Use L<method_ref|/method_ref> instead: C<<$method_ref->code>>

=item param_no
 
Number of parameters when Method accepts ordered arguments

B<DEPRECATED>. Use L<method_ref|/method_ref> instead: C<<$method_ref->len>>

=item param_names

Arrayref with names of parameters when Method accepts named arguments

B<DEPRECATED>. Use L<method_ref|/method_ref> instead: C<<$method_ref->params>>

=item formHandler

True if Method handles form submits

B<DEPRECATED>. Use L<method_ref|/method_ref> instead: C<<$method_ref->formHandler>>

=item pollHandler

True if Method handles Event poll requests

B<DEPRECATED>. Use L<method_ref|/method_ref> instead: C<<$method_ref->pollHandler>>

=item arg

Arrayref with actual arguments when Method accepts ordered args, single
L<Environment object|/"ENVIRONMENT OBJECTS"> for poll handlers, hashref
otherwise.

Note that this is a direct link to Method's C<@_> so it is possible to
modify the arguments in C<before> hook if you need to.

=item env

L<Environment object|/"ENVIRONMENT OBJECTS">, see below. Like L<arg|/arg>,
this is a direct reference to the same object that will be passed to the
Method, so it's possible to modify the env object in C<before> hook.

=item before

Coderef to "before" hook for that Method, or undef

B<DEPRECATED>. Use L<before_ref|/before_ref> instead: C<<$before_ref->code>>

=item instead

Coderef to "instead" hook for that Method, or undef

B<DEPRECATED>. Use L<instead_ref|/instead_ref> instead: C<<$instead_ref->code>>

=item after

Coderef to "after" hook for that Method, or undef

B<DEPRECATED>. Use L<after_ref|/after_ref> instead: C<<$after_ref->code>>

=item result

For C<after> hooks, the Result returned by the Method or C<instead> hook,
whichever got called. Not defined for C<before> and C<instead> hooks.

=item exception

For C<after> hooks, an exception (C<$@>) thrown by Method or C<instead> hook,
if any. Not defined for C<before> and C<instead> hooks.

=item method_called

For C<after> hooks, a reference to the actual code called as Method, if any.
Can be either the Method code itself, C<instead> hook or C<undef> if the
invocation was canceled.

=item orig

A closure that binds Method coderef to its current arguments, allowing to call
it as easily as C<$params{orig}->()>

=back

=back

=head1 ENVIRONMENT OBJECTS

Since Hooks, and sometimes Methods too, need to be aware of their Web
environment, it is necessary to give them access to it in some way
without locking on platform specifics. The answer for this problem is
environment objects.

An environment object provides platform-agnostic interface for accessing
HTTP headers, cookies, form fields, etc, by duck typing. Such object is
guaranteed to have the same set of methods that behave the same way
across all platforms supported by RPC::ExtDirect, avoiding portability
issues.

The interface is modeled after de facto standard CGI.pm:

=over 4

=item *

C<$value = $env-E<gt>param('name')> will retrieve parameter by name

=item *

C<@list = $env-E<gt>param()> will get the list of available parameters

=item *

C<$cookie = $env-E<gt>cookie('name')> will retrieve a cookie

=item *

C<@cookies = $env-E<gt>cookie()> will return the list of cookies

=item *

C<$header = $env-E<gt>http('name')> will return HTTP header

=item *

C<@headers = $env-E<gt>http()> will return the list of HTTP headers

=back

Of course it is possible to use environment object in a more sophisticated
way if you like to, however do not rely on it having a well-known class
name as it is not guaranteed.

=head1 FILE UPLOADS

Ext.Direct offers native support for file uploading by using temporary
forms. RPC::ExtDirect supports this feature; upload requests can be
processed in a formHandler Method. The interface aims to be platform
agnostic and will try to do its best to provide the same results in all
HTTP environments supported by RPC::ExtDirect.

In a formHandler Method, arguments are passed as a hash. If one or more
file uploads were associated with request, the argument hash will contain
'file_uploads' key with value set to arrayref of file hashrefs. Each file
hashref will have the following keys:

=over 4

=item type

MIME type of the file

=item size

file size, in octets

=item path

path to temporary file that holds uploaded content

=item handle

opened IO::Handle for temporary file

=item basename

name portion of original file name

=item filename

full original path as sent by client

=back

All files passed to a Method need to be processed in that Method; existence
of temporary files is not guaranteed after Method returns.

=head1 CAVEATS

In order to keep this module as simple as possible, I had to sacrifice the
ability to automatically distinguish inherited class methods. In order to
declare inherited class methods as Ext.Direct exportable you have to override
them in subclass, like that:
    
    package foo;
    use RPC::ExtDirect;
    
    sub foo_sub : ExtDirect(1) {
        my ($class, $arg) = @_;
    
        # do something
        ...
    }
    
    package bar;
    use base 'foo';
    
    sub foo_sub : ExtDirect(1) {
        my ($class, $arg) = @_;
    
        # call inherited method
        return __PACKAGE__->SUPER::foo_sub($arg);
    }
    
    sub bar_sub : ExtDirect(2) {
        my ($class, $arg1, $arg2) = @_;
    
        # do something
        ...
    }

On the other hand if you don't like class-based approach, just don't inherit
your packages from one another. In any case, declare your Methods explicitly
every time and there never will be any doubt about what Method gets called in
any given Action.

=head1 DEPENDENCIES

RPC::ExtDirect is dependent on the following modules: L<Attribute::Handlers>,
L<"JSON">.

=head1 BUGS AND LIMITATIONS

In version 2.0, ExtDirect attribute was moved to BEGIN phase instead of
default CHECK phase. While this improves compatibility with
Apache/mod_perl environments, this also causes backwards compatibility
problems with Perl older than 5.12. Please let me know if you need to
run RPC::ExtDirect 2.0 with older Perls; meanwhile RPC::ExtDirect 1.x
will provide compatibility with Perl 5.6.0 and newer.

There are no known bugs in this module. Please report problems to author,
patches are welcome.

=head1 SEE ALSO

Alternative Ext.Direct implementations for Perl:
L<CatalystX::ExtJS::Direct> by Moritz Onken,
L<http://github.com/scottp/extjs-direct-perl> by Scott Penrose,
L<Dancer::Plugin::ExtDirect> by Alessandro Ranellucci.

For Web server gateway implementations, see L<CGI::ExtDirect> and
L<Plack::Middleware::ExtDirect> modules based on RPC::ExtDirect engine.

For configurable Ext.Direct API options, see L<RPC::ExtDirect::API>
module.

=head1 AVAILABLE GATEWAYS

=head1 AUTHOR

Alexander Tokarev E<lt>tokarev@cpan.orgE<gt>

=head1 ACKNOWLEDGEMENTS

I would like to thank IntelliSurvey, Inc for sponsoring my work
on version 2.0 of RPC::ExtDirect suite of modules.

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2011-2012 by Alexander Tokarev.

This module is free software; you can redistribute it and/or modify it under
the same terms as Perl itself. See L<"perlartistic">.

=cut

